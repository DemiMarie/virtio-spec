\section{Device groups}\label{sec:Basic Facilities of a Virtio Device / Device groups}

It is occasionally useful to have a device control a group of
other devices. Terminology used in such cases:

\begin{description}
\item[Device group]
        or just group, includes zero or more devices.
\item[Owner device]
        or owner, the device controlling the group.
\item[Member device]
        a device within a group. The owner device itself is not
	a member of the group.
\item[Member identifier]
        each member has this identifier, unique within the group
	and used to address it through the owner device.
\item[Group type identifier]
	specifies what kind of member devices there are in a
	group, how the member identifier is interpreted
	and what kind of control the owner has.
	A given owner can control multiple groups
	of different types but only a single group of a given type,
	thus the type and the owner together identify the group.
	\footnote{Even though some group types only support
			specific transports, group type identifiers
			are global rather than transport-specific -
			a flood of new group types is not expected.}
\end{description}

\begin{note}
Each device only has a single driver, thus for the purposes of
this section, "the driver" is usually unambiguous and refers to
the driver of the owner device.  When there's ambiguity, "owner
driver" refers to the driver of the owner device, while "member
driver" refers to the driver of a member device.
\end{note}

The following group types, and their identifiers, are currently specified:
\begin{description}
\item[SR-IOV group type (0x1)]
This device group has a PCI Single Root I/O Virtualization
(SR-IOV) physical function (PF) device as the owner and includes
all its SR-IOV virtual functions (VFs) as members (see
\hyperref[intro:PCIe]{[PCIe]}).

The PF device itself is not a member of the group.

The group type identifier for this group is 0x1.

A member identifier for this group can have a value from 0x1 to
\field{NumVFs} as specified in the
SR-IOV Extended Capability of the owner device
and equals the SR-IOV VF number of the member device;
the group only exists when the \field{VF Enable} bit
in the SR-IOV Control Register within the
SR-IOV Extended Capability of the owner device is set
(see \hyperref[intro:PCIe]{[PCIe]}).

Both owner and member devices for this group type use the Virtio
PCI transport (see \ref{sec:Virtio Transport Options / Virtio Over PCI Bus}).
\end{description}

\subsection{Group administration commands}\label{sec:Basic Facilities of a Virtio Device / Device groups / Group administration commands}

The driver sends group administration commands to the owner device of
a group to control member devices of the group.
This mechanism can
be used, for example, to configure a member device before it is
initialized by its driver.
\footnote{The term "administration" is intended to be interpreted
widely to include any kind of control. See specific commands
for detail.}

All the group administration commands are of the following form:

\begin{lstlisting}
struct virtio_admin_cmd {
        /* Device-readable part */
        le16 opcode;
        /*
         * 1       - SR-IOV
         * 2-65535 - reserved
         */
        le16 group_type;
        /* unused, reserved for future extensions */
        u8 reserved1[12];
        le64 group_member_id;
        le64 command_specific_data[];

        /* Device-writable part */
        le16 status;
        le16 status_qualifier;
        /* unused, reserved for future extensions */
        u8 reserved2[4];
        u8 command_specific_result[];
};
\end{lstlisting}

For all commands, \field{opcode}, \field{group_type} and if
necessary \field{group_member_id} and \field{command_specific_data} are
set by the driver, and the owner device sets \field{status} and if
needed \field{status_qualifier} and
\field{command_specific_result}.

Generally, any unused device-readable fields are set to zero by the driver
and ignored by the device.  Any unused device-writeable fields are set to zero
by the device and ignored by the driver.

\field{opcode} specifies the command. The valid
values for \field{opcode} can be found in the following table:

\begin{tabular}{|l|l|}
\hline
opcode & Name & Command Description \\
\hline \hline
0x0000 & VIRTIO_ADMIN_CMD_LIST_QUERY & Provides to driver list of commands supported for this group type    \\
0x0001 & VIRTIO_ADMIN_CMD_LIST_USE & Provides to device list of commands used for this group type \\
0x0002 - 0x7FFF & - & Commands using \field{struct virtio_admin_cmd}    \\
\hline
0x8000 - 0xFFFF & - & Reserved for future commands (possibly using a different structure)    \\
\hline
\end{tabular}

The \field{group_type} specifies the group type identifier.
The \field{group_member_id} specifies the member identifier within the group.
See section \ref{sec:Introduction / Terminology / Device group}
for the definition of the group type identifier and group member
identifier.

The \field{status} describes the command result and possibly
failure reason at an abstract level, this is appropriate for
forwarding to applications. The \field{status_qualifier} describes
failures at a low virtio specific level, as appropriate for debugging.
The following table describes possible \field{status} values;
to simplify common implementations, they are intentionally
matching common \hyperref[intro:errno]{Linux error names and numbers}:

\begin{tabular}{|l|l|l|}
\hline
Status (decimal) & Name & Description \\
\hline \hline
00   & VIRTIO_ADMIN_STATUS_OK    & successful completion  \\
\hline
11   & VIRTIO_ADMIN_STATUS_EAGAIN    & try again \\
\hline
12   & VIRTIO_ADMIN_STATUS_ENOMEM    & insufficient resources \\
\hline
22   & VIRTIO_ADMIN_STATUS_EINVAL    & invalid command \\
\hline
other   & -    & group administration command error  \\
\hline
\end{tabular}

When \field{status} is VIRTIO_ADMIN_STATUS_OK, \field{status_qualifier}
is reserved and set to zero by the device.

The following table describes possible \field{status_qualifier} values:
\begin{tabular}{|l|l|l|}
\hline
Status & Name & Description \\
\hline \hline
0x00   & VIRTIO_ADMIN_STATUS_Q_OK               & used with VIRTIO_ADMIN_STATUS_OK  \\
\hline
0x01   & VIRTIO_ADMIN_STATUS_Q_INVALID_COMMAND  & command error: no additional information  \\
\hline
0x02   & VIRTIO_ADMIN_STATUS_Q_INVALID_OPCODE   & unsupported or invalid \field{opcode}  \\
\hline
0x03   & VIRTIO_ADMIN_STATUS_Q_INVALID_FIELD    & unsupported or invalid field within \field{command_specific_data}  \\
\hline
0x04   & VIRTIO_ADMIN_STATUS_Q_INVALID_GROUP    & unsupported or invalid \field{group_type} \\
\hline
0x05   & VIRTIO_ADMIN_STATUS_Q_INVALID_MEMBER   & unsupported or invalid \field{group_member_id} \\
\hline
0x06   & VIRTIO_ADMIN_STATUS_Q_NORESOURCE       & out of internal resources: ok to retry \\
\hline
0x07   & VIRTIO_ADMIN_STATUS_Q_TRYAGAIN         & command blocks for too long: should retry \\
\hline
0x08-0xFFFF   & -    & reserved for future use \\
\hline
\end{tabular}

Each command uses a different \field{command_specific_data} and
\field{command_specific_result} structures and the length of
\field{command_specific_data} and \field{command_specific_result}
depends on these structures and is described separately or is
implicit in the structure description.

Before sending any group administration commands to the device, the driver
needs to communicate to the device which commands it is going to
use. Initially (after reset), only two commands are assumed to be used:
VIRTIO_ADMIN_CMD_LIST_QUERY and VIRTIO_ADMIN_CMD_LIST_USE.

Before sending any other commands for any member of a specific group to
the device, the driver queries the supported commands via
VIRTIO_ADMIN_CMD_LIST_QUERY and sends the commands it is
capable of using via VIRTIO_ADMIN_CMD_LIST_USE.

Commands VIRTIO_ADMIN_CMD_LIST_QUERY and
VIRTIO_ADMIN_CMD_LIST_USE
both use the following structure describing the
command opcodes:

\begin{lstlisting}
struct virtio_admin_cmd_list {
       /* Indicates which of the below fields were returned
       le64 device_admin_cmd_opcodes[];
};
\end{lstlisting}

This structure is an array of 64 bit values in little-endian byte
order, in which a bit is set if the specific command opcode
is supported. Thus, \field{device_admin_cmd_opcodes[0]} refers to the
first 64-bit value in this array corresponding to opcodes 0 to
63, \field{device_admin_cmd_opcodes[1]} is the second 64-bit value
corresponding to opcodes 64 to 127, etc.
For example, the array of size 2 including
the values 0x3 in \field{device_admin_cmd_opcodes[0]}
and 0x1 in \field{device_admin_cmd_opcodes[1]} indicates that only
opcodes 0, 1 and 64 are supported.
The length of the array depends on the supported opcodes - it is
large enough to include bits set for all supported opcodes,
that is the length can be calculated by starting with the largest
supported opcode adding one, dividing by 64 and rounding up.
In other words, for
VIRTIO_ADMIN_CMD_LIST_QUERY and VIRTIO_ADMIN_CMD_LIST_USE the
length of \field{command_specific_result} and
\field{command_specific_data} respectively will be
$DIV_ROUND_UP(max_cmd, 64) * 8$ where DIV_ROUND_UP is integer division
with round up and \field{max_cmd} is the largest available command opcode.

The array is also allowed to be larger and to additionally
include an arbitrary number of all-zero entries.

Accordingly, bits 0 and 1 corresponding to opcode 0
(VIRTIO_ADMIN_CMD_LIST_QUERY) and 1
(VIRTIO_ADMIN_CMD_LIST_USE) are
always set in \field{device_admin_cmd_opcodes[0]} returned by VIRTIO_ADMIN_CMD_LIST_QUERY.

For the command VIRTIO_ADMIN_CMD_LIST_QUERY, \field{opcode} is set to 0x0.
The \field{group_member_id} is unused. It is set to zero by driver.
This command has no command specific data.
The device, upon success, returns a result in
\field{command_specific_result} in the format
\field{struct virtio_admin_cmd_list} describing the
list of group administration commands supported for the group type
specified by \field{group_type}.

For the command VIRTIO_ADMIN_CMD_LIST_USE, \field{opcode}
is set to 0x1.
The \field{group_member_id} is unused. It is set to zero by driver.
The \field{command_specific_data} is in the format
\field{struct virtio_admin_cmd_list} describing the
list of group administration commands used by the driver
with the group type specified by \field{group_type}.

This command has no command specific result.

The driver issues the command VIRTIO_ADMIN_CMD_LIST_QUERY to
query the list of commands valid for this group and before sending
any commands for any member of a group.

The driver then enables use of some of the opcodes by sending to
the device the command VIRTIO_ADMIN_CMD_LIST_USE with a subset
of the list returned by VIRTIO_ADMIN_CMD_LIST_QUERY that is
both understood and used by the driver.

If the device supports the command list used by the driver, the
device completes the command with status VIRTIO_ADMIN_STATUS_OK.
If the device does not support the command list
(for example, if the driver is not capable to use
some required commands), the device
completes the command with status
VIRTIO_ADMIN_STATUS_INVALID_FIELD.

Note: the driver is assumed not to set bits in
device_admin_cmd_opcodes
if it is not familiar with how the command opcode
is used, since the device could have dependencies between
command opcodes.

It is assumed that all members in a group support and are used
with the same list of commands. However, for owner devices
supporting multiple group types, the list of supported commands
might differ between different group types.

\section{Administration Virtqueues}\label{sec:Basic Facilities of a Virtio Device / Administration Virtqueues}

An administration virtqueue of an owner device is used to submit
group administration commands. An owner device can have more
than one administration virtqueue.

If VIRTIO_F_ADMIN_VQ has been negotiated, an owner device exposes one
or more adminstration virtqueues. The number and locations of the
administration virtqueues are exposed by the owner device in a transport
specific manner.

The driver enqueues requests to an arbitrary administration
virtqueue, and they are used by the device on that same
virtqueue. It is the responsibility of the driver to ensure
strict request ordering for commands, because they will be
consumed with no order constraints.  For example, if consistency
is required then the driver can wait for the processing of a
first command by the device to be completed before submitting
another command depending on the first one.

Administration virtqueues are used as follows:
\begin{itemize}
\item The driver submits the command using the \field{struct virtio_admin_cmd}
structure using a buffer consisting of two parts: a device-readable one followed by a
device-writable one.
\item the device-readable part includes fields from \field{opcode}
through \field{command_specific_data}.
\item the device-writeable buffer includes fields from \field{status}
through \field{command_specific_result} inclusive.
\end{itemize}

For each command, this specification describes a distinct
format structure used for \field{command_specific_data} and
\field{command_specific_result}, the length of these fields
depends on the command.

However, to ensure forward compatibility
\begin{itemize}
\item drivers are allowed to submit buffers that are longer
than the device expects
(that is, longer than the length of
\field{opcode} through \field{command_specific_data}).
This allows the driver to maintain
a single format structure even if some structure fields are
unused by the device.
\item drivers are allowed to submit buffers that are shorter
than what the device expects
(that is, shorter than the length of \field{status} through
\field{command_specific_result}). This allows the device to maintain
a single format structure even if some structure fields are
unused by the driver.
\end{itemize}

The device compares the length of each part (device-readable and
device-writeable) of the buffer as submitted by driver to what it
expects and then silently truncates the structures to either the
length submitted by the driver, or the length described in this
specification, whichever is shorter.  The device silently ignores
any data falling outside the shorter of the two lengths. Any
missing fields are interpreted as set to zero.

Similarly, the driver compares the used buffer length
of the buffer to what it expects and then silently
truncates the structure to the used buffer length.
The driver silently ignores any data falling outside
the used buffer length reported by the device.  Any missing
fields are interpreted as set to zero.

This simplifies driver and device implementations since the
driver/device can simply maintain a single large structure (such
as a C structure) for a command and its result. As new versions
of the specification are designed, new fields can be added to the
tail of a structure, with the driver/device using the full
structure without concern for versioning.
